## 아이템 1: 타입스크립트 알아보기

### 타입스크립트는 자바스크립트의 슈퍼셋(상위집함, 초집합)

- == 자바스크립트는 타입스크립트의 부분집합
- == 타입스크립트는 자바스크립트 문법 + 타입스크립트만의 문법
- => 타입스크립트를 자바스크립트의 컴파일 타임에 에러 체크용으로 사용가능 (100% X)
- 모든 자바스크립트는 타입스크립트이지만, 타입 체커는 일부 자바스크립트만 통과함
- 타입 스크립트 타입 시스템은 자바스크립트의 런타임 도오작을 '모델링'함
- 즉 타입스크립트는 자바스크립트이지만, 일반적인 개념의 자바스크립트는 아니다 (좀더 좁은, 빡센 자바스크립트).
- 타입 체커를 통과하지만 런타임 오류가 생길 수 있음 (100% 못 잡음)

자바스크립트 런타임 동작을 모델링하는ㄴ 타입시스템을 가짐 => 런타임 오류를 컴파일 타임에 잡을려고함 (단 타입 체커 통과시 못잡음)

## 아이템 2: 타입스크립트 설정 이해하기

타입스크립스 컴파일러 설정 목록: tsc --noImplicitAny program.ts or tsconfig.json => tsconfig.json 설정 권장

* noImplicitAny: 변수들이 미리 정의된 타입을 가져야 하는지 여부 (암시적 any X)
* strictNullChecks: null과 undefined가 모든 타입에서 허용되는지 여부
* strict:  엄격한 체크..(모든 설정 on?)

## 아이템 3: 코드 생성과 타입이 관계없음을 이해하기

타입스크립트 컴파일러의 큰 역할 2가지

* 최신 ts / js를 브라우저에서 동작할 수 있게 구버전의 js로 트랜스파일 함 
  (트랜스파일(transfile): 동일한 동작을 하는 다른 형태의 소스코드로 변환)
* 코드의 타입 오류 체크

컴파일과 타입 체크는 동립적으로 동작함 => 타입 오류가 있어도 컴파일 가능

* noEmitOnError: 타입 오류가 있을 때 컴파일하지 않으려고할때

런타임에 타입 체크 불가능

- `instanceof` 체크는 런타임에 일어나지만, interface는 ts 타입이라 컴파일 과정에 제거됨 (모든 인터페이스, 타입, 타입 구문은 제거됨)
- (타입 체커 사용) 속성이 존재하는지 체크해야함 (ex: `if ('height' in shape)`) 
- (태그 기법) 런타임에 접근 가능한 타입 정보를 필드로 젖ㅇ (ex: `if (shape.kind === 'rectangle')`)
- 인터페이스를 클래스로 변환시 타입과 값으로 사용 가능

=> 타입 연산은 런타임 동작에 아무런 영향이 없음 == 값 정제하기 위해 런타임 타입 체크를 하고 자바스크립트 연산을 해야함
     (ex: `typeof(val) === 'string' ? Number(val) : val`)

런타임에 할당되는 값이 타입과 다를 수 있음

타입스크립튼는 타입으로 함수 오버로드 불가능 (타입 수준에서만 가능)

타입스크립트의 타입은 런타임 성능에 영향 없음
런타임 오버헤드가 없는 대신, 타입스크립트 컴파일러는 빌드타임 오버헤드가 있음 (컴파일은 빠른편, 증분 빌드시 체감됨?)

## 아이템 4: 구조적 타이핑에 익숙해지기

덕 타이핑: 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식

구조적 타이핑: ts는 js의 런타임 동작을 모델링함 -> js에서 구조가 같으면 서로 명시된 관계가 없어도 호환가능

- 구조가 일치 하지않고, 추가적인 필드가 더 있는 경우도 허용됨 => 추상화하기는 좋음...
- 객체를 클래스 생성자로 생성하지 않아도, 구조가 같다면 같은 타입으로 할당 가능 
  (ex: 
  `class C {`
  `foo: string;`
  `constructor(foo: string) {`
  `this.foo = foo;`
  `}`
  `{const d: C = {foo: 'object literal'};`
  )

봉인된(sealed) / 정확한(precise) 타입: 매개변수의 타입에 선언된 속성만 가지는 타입

## 아이템 5: any 타입 지양하기

ts의 타입 시스템은 점진적(gradiual)이고, 선택적(optional)이다.

* any 타입은 함수 계약(contract)을 무시한다.
* 자동 완성 기능 지원 X (ex: .찍어서 프로퍼티 목록 보기)
* 이름 변경 지원 X (any타입은 트레킹이 되지 안는가..?)
* any 타입은 모든 상황을 먹어린다.

요약

* any 타입은 타입 체커와 js 언어 서비스를 무력화시킨다.
* any 타입은 문제점을 감춘다.

## 아이템 6: 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트 설치하면 실행 할 수 있는거 2가지

* 타입스크립트 컴파일러
* 단독으로 실행할 수 있는 타입스크립트 서버 (tsserver)

## 아이템 7: 타입이 값들의 집합이라고 생각하기

* Never: 공집합, 아무 값도 포함하지 않음
* 리터럴(literal) 타입, 유닛(unit)타입: 한 가지 값만 포함하는 타입 (ex: `type A = 'A';`)
* 유니온(union) 타입 (== 값 집합들의 합집합): 2개 이상을 묶은 타입 (ex: `type AB = 'A' | 'B'`)
* 할당 가능한: a의 원소 (값과 타입의 관계) or a의 부분 집합(두 타입의 관계)를 의미함
* 잉여 속성 체크 (excess property checking): 특정 상황에서만 추가 속성을 허용하지 않는 것
* & 연산자: 두 타입의 인터섹션(intersection, 교집합)을 계산함
* | (유니온): 두 타입에 공통으로 속하는 속성
* extends: a의 부분 집합 (타입의 집합 관계와 속성의 집합 관계는 반대됨) 

요약

* 타입은 값의 집합
* 타입스크립트 타입은 상속 관계가 아닌 집합으로 표현됨 (= 서브타입이 아니라도 겹쳐 질 수 있음)
* 타입 연산은 집합의 범위에 적용됨

## 아이템 8: 타입 공간과 값 공간의 심벌 구분하기

클래스는 자바스크립트의 런타임 개념

타입스크립트의 심벌(symbol)은 타입 공간이나 값 공간 중의 한 곳에 존재함

instanceof: 자바스크립트의 런타임 연산자, 값에 대해서 연산함

클래스가 타입으로 쓰일때는 형태가 사용되고, 값으로 쓰일 때는 생성자가 사용됨

typeof: 타입 관점에서 값을 읽어 타입스크립트 타입을 반환함, 값 관점에서 자바스크립트 런타임의 typeof 연산자가 됨(심벌의 런타임 타입을 가리키는 문자열)

요약

* type과 interface 같은 키워드는 타입 공간에만 존재함

**> 다시 봐야함 <**

## 아이템 9: 타입 단언보다는 타입 선언을 사용하기

- 타입 선업: 변/상수를 선언 할때 타입을 명시하는 것
- 타입 단언: as 키워드를 이용해 타입을 간주하는 것 (강제로 타입을 지정하므로 타입 체커에게 오류를 무시하라고 하는 것)

55쪽 부터



타입 구문: 변수, 함수등의 타입을 명시하는 것

클로저 컴파일러

리터럴

타입 체커

타입 구문

null undefined any

덕 타이핑 (duck typing))